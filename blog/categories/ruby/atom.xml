<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | House of Rails]]></title>
  <link href="http://andrewhouse.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://andrewhouse.github.io/"/>
  <updated>2014-08-14T09:51:00-04:00</updated>
  <id>http://andrewhouse.github.io/</id>
  <author>
    <name><![CDATA[Andrew House]]></name>
    <email><![CDATA[andrewhouse621@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gem Choices]]></title>
    <link href="http://andrewhouse.github.io/blog/2014/08/13/gem-choices/"/>
    <updated>2014-08-13T16:37:02-04:00</updated>
    <id>http://andrewhouse.github.io/blog/2014/08/13/gem-choices</id>
    <content type="html"><![CDATA[<p>Gem&rsquo;s make my Rails world go round. <br>
However, there are so many gems around that it would take entirely too long
to comb through them all.
I do have a method that helps me select certain gems from others. <br>
<strong>Documentation.</strong><br>
If a gem is lacking in how-to&rsquo;s, tutorials, or efficient documentation-I
typically skip over it.
For example, one of my favorite gems is <a href="https://github.com/plataformatec/simple_form">Simple Form</a>.
Simple Form allows forms to be a little easier to read.
My favorite part about it?<br>
Look at all of that documenation on the Github page.<br>
I love it.
There have been situations where I use gems that don&rsquo;t have great documentation.
Typically that is when I&rsquo;m desperate for something and have exhausted my resources.
Odds are, the gem is a failure and I crawl into a little hole for a few minutes.
Alas, gems are great to use and their documentation/codebase allows for steady
knowledge and easy implementation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sinatra Is Fun]]></title>
    <link href="http://andrewhouse.github.io/blog/2014/08/11/sinatra-is-fun/"/>
    <updated>2014-08-11T21:09:49-04:00</updated>
    <id>http://andrewhouse.github.io/blog/2014/08/11/sinatra-is-fun</id>
    <content type="html"><![CDATA[<p>I never really gave Sinatra a chance. <br>
After reading articles after articles about how much better Rails is than
Sinatra, I kind of swept it under the rug.
I was sooooo wrong. <br>
Sinatra is crazy light weight.
Not as many bells, whistles, and not near as many headaches that come with Rails.
It&rsquo;s simplistic, and I like that.
Today I built <a href="http://andrew-sinatra.herokuapp.com/" title="Andrew House - Sinatra">a fun Sinatra app</a>
and I had a really great time.
I didn&rsquo;t try to make it too complicated, just trying to get used to haml and
getting into the groove of how sinatra should feel.<br><br>
I enjoyed how some of the magic that you take for granted in Rails is peeled
apart in Sinatra.
Making my own get/post requests and assigning routes was fun.
I may be overplaying it, and I know how beneficial rails will be when I take
on a larger app. But I have to say that now I will turn to sinatra for low
level simplistic apps. Kudos to James for making us play with Sinatra.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Starting Over]]></title>
    <link href="http://andrewhouse.github.io/blog/2014/08/08/starting-over/"/>
    <updated>2014-08-08T23:37:13-04:00</updated>
    <id>http://andrewhouse.github.io/blog/2014/08/08/starting-over</id>
    <content type="html"><![CDATA[<p>I LOVE to play around with new features. <br>
Tonight I was playing around with omniauth-github and trying to log in via rails.
I was able to log in (horray!), but I had forgotten what I was supposed to be
doing initially.
It happens to me every now and then; I get feature focused. <br><br>
I&rsquo;m so focused on getting this one little thing to work I lose track of
my goal. It&rsquo;s times like this, when I&rsquo;m barely into the project, and I was
able to get my feature to work.
I find that it&rsquo;s best to scrap it and start over.
My reasoning?<br>
  <li>Start on a path where I am able to remain focused.
  <li>When it is time to create the feature again; I will do it again from scratch,
forcing myself to learn.
  <li>In future projects, I will know to be well prepared and focused from the get go.
<br><br>
Long story short. <br>
I played around with a cool thing, got it to work, messed up, started over, and
didn&rsquo;t loose any passion.
Not a bad thing if you ask me.
I&rsquo;ll learn, grow, and do a better job next time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Ruby Chose Me]]></title>
    <link href="http://andrewhouse.github.io/blog/2014/08/06/how-ruby-chose-me/"/>
    <updated>2014-08-06T08:49:11-04:00</updated>
    <id>http://andrewhouse.github.io/blog/2014/08/06/how-ruby-chose-me</id>
    <content type="html"><![CDATA[<p>Javascript was my first programming language.
While it was fun to use, it was also very syntax heavy.
The amount of ()&rsquo;s and {}&rsquo;s pretty much drove me insane.  <br>
After learning the basics of Javascript I started to look for other
languages that would be relevant to my goal of web development.
I had come to learn how Javascript was incredibly important making web
pages function, and I wanted to learn the skills to drive the essential
pieces that run in the background. That&rsquo;s right, I wanted to take a look
into the back-end. <br></p>

<!-- more -->


<p>After researching for countless days I finally stumbled upon Ruby on Rails.
It seemed that Rails was a great way to start looking into the backend.
However, the majority of places I saw said to absolutly not start Rails
until I was fluent in Ruby.
Then a lightbulb moment came.
I remember seeing a Ruby course when I was going over the Javascript codeacademy
course.
There I went, headfirst into Ruby without a clue of what it was.<br><br>
I thought Ruby was joking with me.
Hardly any ()&rsquo;s and only {}&rsquo;s with hashes and blocks. Are you serious?
It was fluid, less verbose, and object oriented.
I fell head over heels.
From that point on I focused mainly on Ruby and learning how to properly structure
methods, classes, and everything I could.
I&rsquo;ve got to the point to where just getting something to work the way I want to isn&rsquo;t
enought, I need to have it be in best practice.
Using proper standards and conventions adopted by professionals.
Ruby is a ton of fun.
I&rsquo;m incredibly passionate about it and it has made me a more passionate developer.<br><br>
Ruby pulled me into it&rsquo;s world and I couldn&rsquo;t be happier.
From there I went to learn basic Rails and make a few web apps of my own.
Currently, I am attending the IronYard in Atlanta, GA to learn more
advanced Ruby and Rails.
By the end of this I feel I will be absolutely be prepared to be a critical
asset to any team. <br><br>
I have Ruby to thank for all of it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pry-ing Apart Code]]></title>
    <link href="http://andrewhouse.github.io/blog/2014/08/05/pry-ing-apart-code/"/>
    <updated>2014-08-05T20:36:37-04:00</updated>
    <id>http://andrewhouse.github.io/blog/2014/08/05/pry-ing-apart-code</id>
    <content type="html"><![CDATA[<p>I like to think of writing code similar to designing puzzles.
The more simple the code, the easier to dissect each individual element and
know the code with exact precision.
However, I have a fondness for diving deep into code I don&rsquo;t understand.
One of my favorite things to do is to find a method on ruby-docs that I know
nothing about, and pick it apart piece by piece.
Originally, I used mass amounts of puts and tabbing back and forth between
my editor and irb. During my first day at the IronYard my Instructor James
introduced me to Pry. <br><br></p>

<!-- more -->


<p>Let me say, pry is a dream. <br><br>
Pry is pretty sweet because I&rsquo;m able to use pry in place of irb.
It also uses a colorized
text to help me instantly recognize what the type the presented code is.
For me, the most powerful feature of pry is <code>binding.pry</code>.
When I&rsquo;m wanting to find out what a particular piece of code is doing
at a specific point in time, I drop <code>binding.pry</code> at that specific
line. Then when I run the code, pry automatically opens and I&rsquo;m given the ability
to check specific states of code, even during complicated loops.
In addition, I like to use the pry-byebug gem to be able to go line by line,
continuously being able to check code and debug/figure out whats going on.<br><br>
As a Junior Dev I find these practices to be crucial.
There are plenty of times I have no idea what I&rsquo;m doing, and by calmly
dissecting the code, I can pull myself through even the hardest bits of code.</p>
]]></content>
  </entry>
  
</feed>
